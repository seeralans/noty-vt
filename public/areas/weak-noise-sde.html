<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>On the Gaussian envelopes of weak-noise stochastic differential equations.</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="stylesheet" href="/assets/css/modus-operandi.css" id="noty-theme">
</head>
<body>
  <header class="noty-header">
    <nav class="noty-nav">
  <a href="/index.html" class="noty-nav-brand">Home</a>
  <ul class="noty-nav-list">
    <li><a href="/areas/index.html">Areas</a></li>
    <li><a href="/projects/index.html">Projects</a></li>
    <li><a href="/personal/index.html">Personal</a></li>
    <li><a href="/pages/manual.html">Manual</a></li>
  </ul>
  <div class="noty-nav-actions">
    <button class="theme-toggle" type="button" title="Toggle theme">ðŸŒ“</button>
    <button class="sidenote-toggle" type="button" title="Toggle notes">â˜°</button>
  </div>
</nav>

  </header>
  <main class="page">
    <aside class="left-bar">
      <div id="toc"></div>
    </aside>
    <article class="content noty-article">
      <h1 class="noty-title">On the Gaussian envelopes of weak-noise stochastic differential equations.</h1>
      <p>
\[
\renewcommand{\bm}[1]{\boldsymbol{#1}}%
\renewcommand{\ensuremath}[1]{{#1}}%
\renewcommand{\note}[2][orange]{\colorbox{#1!20}{#2}}%
%
\renewcommand{\varvb}{\bm{v}}%
\renewcommand{\varv}{v}%
%
% \DeclareBoldMathCommand\varv{v}%
\renewcommand{\order}[1]{\mathcal{O}{({#1})}}%
%
\renewcommand{\ee}{{\mathrm{e}}}%
\renewcommand{\acos}{\mathrm{acos}}%
\renewcommand{\vphi}{\varphi}%
\renewcommand{\veps}{\varepsilon}%
\renewcommand{\vthe}{\vartheta}%
%
%
\renewcommand{\lb}{\left(}%
\renewcommand{\rb}{\right)}%
%
\renewcommand{\ls}{\left[}%
\renewcommand{\rs}{\right]}%
%
\renewcommand{\lc}{\left\{}%
\renewcommand{\rc}{\right\}}%
%
\renewcommand{\ld}{\left.}%
\renewcommand{\rd}{\right.}%
%
\renewcommand{\la}{\left\langle}%
\renewcommand{\ra}{\right\rangle}%
%
\renewcommand{\lp}{\left|}%
\renewcommand{\rp}{\right|}%
%
\renewcommand{\acosh}{\mathrm{acosh}}%
\renewcommand{\floor}[1]{{\lfloor{#1}\rfloor}}%
%
%
\renewcommand{\ffrac}[2]{{#1}/{#2}}%
\renewcommand{\carr}{\curvearrowright}%
\renewcommand{\carl}{\curvearrowleft}%
\renewcommand{\ztrans}[1]{\widetilde{#1}}%
\renewcommand{\wt}{\widetilde}%
\renewcommand{\sgn}{\mathrm{sgn}}%
\renewcommand{\tr}{\mathrm{Tr}}%
\renewcommand{\mat}[1]{\mathbf{#1}}%
\renewcommand{\mmat}[1]{\underline{\bm{#1}}}%
\renewcommand{\mvec}[1]{\bm{#1}}%
\renewcommand{\nvec}{\mvec{n}}%
\renewcommand{\xvec}{\mvec{x}}%
%
\renewcommand{\mdet}[1]{\left|#1\right|}%
\renewcommand{\mrm}[1]{\ensuremath{\mathrm{{#1}}}}%
\renewcommand{\rmd}{\ensuremath{\mathrm{{d}}}}%
%
\renewcommand{\trans}{\ensuremath{\scriptsize\mathsf{T}}}%
\renewcommand{\thh}{{\ensuremath\mathrm{th}}}%
\renewcommand{\grad}[2]{\ensuremath{{\nabla_{\!{{#1}}}}{#2}}}%
%
\renewcommand{\giv}{\,|\,}%
\renewcommand{\matidx}[2]{{{#1}, {#2}}}%
\renewcommand{\mbinom}[2]{{\ensuremath{\begin{pmatrix}{#1}\\{#2}\end{pmatrix}}}}%
%
%
\renewcommand{\apref}[1]{Appendix~\ref{#1}}%
\renewcommand{\checked}{{\color{green}\textbf{CHECKED}}\\}%
\renewcommand{\changed}{{\color{red}\textbf{DISCUSS}}\\}%
%
%
% symbols%
\renewcommand{\sstate}[1][\nvec]{\ensuremath{\sigma_{{#1}}}}%
%
\renewcommand{\disp}{\ensuremath{g}}%
%
\renewcommand{\nt}[2][]{\ensuremath{N^{_{#1}}_{^{^\mathrm{#2}}}}}%
\renewcommand{\ntb}[2][]{\ensuremath{{\mvec{N}}^{_{#1}}_{^{^\mathrm{#2}}}}}%
%
%
\renewcommand{\xep}[2][]{\ensuremath{{\rho}^{_{#1}}_{^{^\mathrm{#2}}}}}%
%
\renewcommand{\xt}[1]{\ensuremath{{\color{sol_red}\xi}_{_{\mathrm{#1}}}}}%
%
\renewcommand{\xtt}[2][]{\ensuremath{{\color{sol_red}\xi}^{{#1}}_{_{\mathrm{#2}}}}}%
\renewcommand{\xtd}[1]{\ensuremath{{\color{sol_red}\dot{\xi}}_{_{\mathrm{#1}}}}}%
\renewcommand{\et}[2][\vphi , \vthe]{\ensuremath{{\color{sol_blue}\eta}_{_{\mathrm{#2}}}{\lb {#1} \rb}}}%
%
%
\renewcommand{\jt}[1]{\ensuremath{J_{^{^\mathrm{#1}}}}}%
\renewcommand{\jtt}[1]{\ensuremath{\tilde{J}_{^{^\mathrm{#1}}}}}%
%
%
\renewcommand{\configs}[1][]{\ensuremath{\lc \sstate[\nvec] \rc_{{#1}}}}%
\renewcommand{\motif}[3]{\ensuremath{\mathcal{N}^{{#1}}_{{#2}}({#3})}}%
\renewcommand{\motiff}[1]{\ensuremath{n_{{#1}}}}%
%
%
\renewcommand{\intpsym}{\varphi}%
\renewcommand{\intmsym}{\pi}%
\renewcommand{\intpv}{\mvec{\intpsym}}%
\renewcommand{\intmv}{\mvec{\intmsym}}%
\renewcommand{\intpsyms}{\bar{\intpv}}%
\renewcommand{\intmsyms}{\bar{\intmv}}%
\renewcommand{\intpvs}{\mvec{\intpsyms}}%
\renewcommand{\intmvs}{\mvec{\intmsyms}}%
%
\renewcommand{\diffu}[3][]{\ensuremath{\frac{\mathrm{d}^{#1}{#2}}{\mathrm{d}{#3}^{#1}}}}%
\renewcommand{\diffl}[3][]{\ensuremath{\frac{\mathrm{d}^{#1}}{\mathrm{d}{#3}^{#1}} {#2}}}%
%
\renewcommand{\pdiffu}[3][]{\ensuremath{\frac{\partial^{#1}{#2}}{\partial{#3}^{#1}}}}%
\renewcommand{\pdiffl}[3][]{\ensuremath{\frac{\partial^{#1}}{\partial{#3}^{#1}} {#2}}}%
%
%
\renewcommand{\mpdiff}[3][]{\ensuremath{\partial^{#1}_{#3}{#2}}}%
%
\renewcommand{\fpdiffu}[3][]{\ensuremath{\frac{\partial^{#1}{#2}}{\partial{#3}}}}%
%
%
\renewcommand{\grad}[2][]{\ensuremath{{\nabla_{\!{{#1}}}}{#2}}}%
%
%
\renewcommand{\ufunc}[1]{\ensuremath{u{\ls {#1} \rs}}}%
\renewcommand{\ufuncr}{\ensuremath{u}}%
\renewcommand{\ufuncf}[1]{\ensuremath{\frac{1}{2}\ls 1 - \tanh{\lb \frac{1}{2} {#1} \rb} \rs}}%
%
\renewcommand{\ew}[3]{\ensuremath{W^{{#1}}_{\mathrm{#2}}{\lb {#3} \rb}}}%
\renewcommand{\iw}[3]{\ensuremath{w^{{#1}}_{\mathrm{#2}}{\lb {#3} \rb}}}%
%
%
%
%
\renewcommand{\ewf}[4]{\ensuremath{W^{_\mathrm{{#1}}}_{^{\, \mathrm{{#2}}| {#3}}}{\lb {#4} \rb}}}%
\renewcommand{\ewff}[5]{\ensuremath{W^{_{\mathrm{{#1}}| {#4}}}_{^{\, \mathrm{{#2}}| {#3}}}{\lb {#5} \rb}}}%
%
\renewcommand{\swf}[4][]{\ensuremath{N^{_\mathrm{{#1}}}_{^{\, \mathrm{{#2}}| {#3}}}{\lb {#4} \rb}}}%
\renewcommand{\swff}[5][]{\ensuremath{N^{_{\mathrm{{#1}}| {#4}}}_{^{\, \mathrm{{#2}}| {#3}}}{\lb {#5} \rb}}}%
%
\renewcommand{\rcwf}[3]{\ensuremath{\tau^{_\mathrm{{#1}}}_{^{\, \mathrm{{#2}}| {#3}}}}}%
\renewcommand{\rcwff}[4]{\ensuremath{\tau^{_{\mathrm{{#1}}| {#4}}}_{^{\, \mathrm{{#2}}| {#3}}}}}%
%
\renewcommand{\scwf}[3]{\ensuremath{\mvec{\Delta}^{_\mathrm{{#1}}}_{^{\, \mathrm{{#2}}| {#3}}}}}%
\renewcommand{\scwff}[4]{\ensuremath{\mvec{\Delta}^{_{\mathrm{{#1}}| {#4}}}_{^{\, \mathrm{{#2}}| {#3}}}}}%
%
%
\renewcommand{\edwf}[3]{\ensuremath{\Delta H^{_\mathrm{{#1}}}_{^{\, \mathrm{{#2}}| {#3}}}}}%
\renewcommand{\edwff}[4]{\ensuremath{\Delta H^{_{\mathrm{{#1}}| {#4}}}_{^{\, \mathrm{{#2}}| {#3}}}}}%
%
\renewcommand{\gwf}[4][G]{\ensuremath{{#1}^{_\mathrm{{#2}}}_{^{\, \mathrm{{#3}}| {#4}}}}}%
\renewcommand{\gwff}[5][G]{\ensuremath{{#1}^{_{\mathrm{{#2}}| {#5}}}_{^{\, \mathrm{{#3}}| {#4}}}}}%
%
%
\renewcommand{\iwf}[4]{\ensuremath{w^{_\mathrm{{#1}}}_{^{ \mathrm{{#2}}| {#3}}}{\lb {#4} \rb}}}%
\renewcommand{\iwfs}[3]{\ensuremath{w^{_\mathrm{{#1}}}_{^{ \mathrm{{#2}} }}{\lb {#3} \rb}}}%
% w^{_\mathrm{D}}_{^{\mathrm{T} |  {i,j}}}(\vphi, \vtheta, \xt{TD})%
%
%
\renewcommand{\enwf}[3]{\ensuremath{u^{_\mathrm{{#1}}}_{^{ \mathrm{{#2}}| {#3}}}}}%
\renewcommand{\enwfs}[2]{\ensuremath{u^{_\mathrm{{#1}}}_{^{ \mathrm{{#2}} }}}}%
%
%
\renewcommand{\sech}{\ensuremath{\mathrm{sech}}}%
%
\renewcommand{\idef}{\ensuremath{\overset{\,\mathrm{def}\,}{=}}}%
\renewcommand{\prob}{\ensuremath{\mathbb{P}}}%
%
%
\renewcommand{\wptt}[1]{\ensuremath{\iwf{T}{E}{1, 0}{{#1}}}}%
\renewcommand{\wptd}[1]{\ensuremath{\iwf{D}{E}{1, 0}{{#1}}}}%
\renewcommand{\wpdd}[1]{\ensuremath{\iwf{D}{E}{0, 1}{{#1}}}}%
\renewcommand{\wpdt}[1]{\ensuremath{\iwf{T}{E}{0, 1}{{#1}}}}%
%
\renewcommand{\wmtt}[1]{\ensuremath{\iwf{E}{T}{1, 0}{{#1}}}}%
\renewcommand{\wmtd}[1]{\ensuremath{\iwf{E}{D}{1, 0}{{#1}}}}%
\renewcommand{\wmdd}[1]{\ensuremath{\iwf{E}{D}{0, 1}{{#1}}}}%
\renewcommand{\wmdt}[1]{\ensuremath{\iwf{E}{T}{0, 1}{{#1}}}}%
%
%
\renewcommand{\wptte}[1]{\ensuremath{\iwf{T}{D}{1, 0}{{#1}}}}%
\renewcommand{\wpdde}[1]{\ensuremath{\iwf{D}{T}{0, 1}{{#1}}}}%
\renewcommand{\wmtte}[1]{\ensuremath{\iwf{D}{T}{1, 0}{{#1}}}}%
\renewcommand{\wmdde}[1]{\ensuremath{\iwf{T}{D}{0, 1}{{#1}}}}%
%
\renewcommand{\wpttt}[1]{\ensuremath{\iwf{T}{D}{2, 0}{{#1}}}}%
\renewcommand{\wpddd}[1]{\ensuremath{\iwf{D}{T}{0, 2}{{#1}}}}%
%
\renewcommand{\wmttt}[1]{\ensuremath{\iwf{D}{T}{2, 0}{{#1}}}}%
\renewcommand{\wmddd}[1]{\ensuremath{\iwf{T}{D}{0, 2}{{#1}}}}%
%
\renewcommand{\wpttd}[1]{\ensuremath{\iwf{T}{D}{1, 1}{{#1}}}}%
\renewcommand{\wmttd}[1]{\ensuremath{\iwf{D}{T}{1, 1}{{#1}}}}%
%
\]
</p>
<div id="outline-container-org78869ba" class="outline-2">
<h2 id="org78869ba"><span class="section-number-2">1.</span> Background</h2>
<div class="outline-text-2" id="text-1">
<p>
Consider the autonomous  <a href="../../general-notes/stoch_cal.html">SDE</a> 
</p>

\begin{equation}
\label{orga4130d7}
\mrm{d}x_t = a( x_t)\mrm{d}t + \alpha(\epsilon) b( x_t) \mrm{d}W_t
\end{equation}

<p>
where \(x_t \in \mathbb{R}^n\) is the random variable, \(a: \mathbb{R}^n \to \mathbb{R}^n\) is the deterministic drift field, 
\(b: \mathbb{R}^d \to \mathbb{R}^{mn}\) is the noise amplitude, \(W_t \in \mathrm{R}^m\) is \(m\) dimensional Wiener process and \(\alpha(\epsilon)\) is a sufficiently smooth gauge function such that the directional limit \(\lim_{\epsilon \to 0^+} \alpha(\epsilon)= 0\). The parameter \(\epsilon\) represents perturbation. In the limit \(\epsilon \to 0\), \eqref{orga4130d7} is reduced to the deterministic ODE
</p>

\begin{equation}
\label{org38fb0fc}
\diffu{x}{t} = a(x).
\end{equation}

<p>
Assuming that there exists a stable invariant manifold \(x^{*} \subset \mathbb{R}^n\) to the ODE, we wish parameterise  Gaussian envelope around it which is possible only when the noise sufficiently small and additive.
</p>

<p>
Suppose we have a manifold \(\mathcal{M}^s \subset \mathbb{R}^n\), such that 
</p>

\begin{equation}
\label{orgf383a63}
a(x) \in \mathcal{T}_{x}\mathcal{M}^s\quad \forall x \in \mathcal{M}^s,
\end{equation}

<p>
where \(\mathcal{T}_x \cdot\) is the tangent space of the manifold. We have concentration of measure if and only if the manifold \(\mathcal{M}^s\) is (locally) attracting. That is given a local neighbourhood \(\Lambda\) such that \(\mathcal{M}^s \subset \Lambda \subset \mathbb{R}^n\), we define
</p>

\begin{equation}
\label{orga91fb8d}
\mathcal{M}^s(x) \idef {\lc x_0 \in \Lambda \;|\;  \Psi_t(x_0) \to x\ \text{as}\ t \to \infty\ \text{and}\ \Psi_t(x_0) \in \Lambda, \forall x_0 \in \Lambda   \rc}.
\end{equation}

<p>
Consider now a stable orbit \(\bar{x}(s) \in \mathcal{M}^s\) where \(s\) is some suitable parameterisation, e.g. \(\bar{x}(s) = x^*\) or a fixed point or \(\bar{x}(s) = {\lc (\cos{s}, \sin{s}) \;|\; s \in [0, 2\pi) \rc}\) for a cycle of radius one centred at \((0, 0)\), we can consider a small stochastic perturbation to the smooth invariant orbits by letting
</p>

\begin{equation}
\label{org4aa776a}
x_t = \bar{x}(t) + \beta(\epsilon)y_t \implies y_t = \frac{1}{\beta{(\epsilon)}} {\ls x_t - \bar{x}(t) \rs},
\end{equation}

<p>
where \(y_t\) is the perturbation and \(\beta(\epsilon)\) is a smooth gauge function such that \(\beta(\epsilon) \to 0\) as \(\epsilon \to 0\). Using It\(\bar{\mrm{o}}\)'s lemma we have
</p>

\begin{equation}
\label{orga3b1ecb}
\mrm{d}y_t = -\frac{1}{\beta} \ls \pdiffu{\bar{x}(t)}{t} \mrm{d}t -  \mrm{d}{x_t} \rs,
\end{equation}

<p>
where we have dropped the dependence on \(\epsilon\) in the notation of the gauge function. Before substituting \eqref{orga4130d7} into \eqref{orga3b1ecb} it is convenient to insert first \(x_t = \bar{x}(t) + \beta y_t\) into the former and expand for small \(\beta\) to first order
</p>

\begin{align}
\label{org2ffa79c}
\mrm{d}x^i_t &= \ls a^{i}(\bar{x}(t)) + J^{i}_{j}(\bar{x}(t)) (x^{j}_t - \bar{x}^{j}(t)) \rs \mrm{d}t 
+ \alpha \ls b^{i}_{k}(\bar{x}(t))
+ (x^{j}_t - \bar{x}^{j}(t)) \mpdiff{b^{i}_k(\bar{x}(t))}{x^{j}}\rs\mrm{d}W^{k}_{t}, \\
\mrm{d}x^i_t &= \ls a^{i}(\bar{x}(t)) +  \beta J^{i}_{j}(\bar{x}(t)) y^{j}_t \rs \mrm{d}t 
+ \alpha \ls b^{i}_{k}(\bar{x}(t))
+ \beta y^{j}_t \mpdiff{b^{i}_k(\bar{x}(t))}{x^{j}}\rs\mrm{d}W^{k}_{t},
\end{align}

<p>
where we employ Einstein summation convention, i.e. repeated indicies are summed over, and 
</p>

\begin{equation}
\label{org8b03e0c}
J^{i}_{j}(\bar{x}(t)) = \mpdiff{a^{i}(x)}{x^j} \;|_{x \to \bar{x}(t)},
\end{equation}

<p>
is the Jacobian of the vector field \(a(x)\) evaluated at \(\bar{x}(t)\). Substituting \eqref{org2ffa79c} into \eqref{orga3b1ecb} we obtain (to first order in \(\beta\))
</p>

\begin{equation}
\label{org943dbac}
\mrm{d}y^{i}_t = J^{i}_{j}(\bar{x}(t)) y^{j}_t \mrm{d}t + 
\frac{\alpha}{\beta}b^{i}_{k}(\bar{x}(t))\mrm{d}{W^k_t} + \alpha y^{j}_t \mpdiff{b^{i}_k(\bar{x}(t))}{x^{j}}\mrm{d}{W^k_t}.
\end{equation}

<p>
For the sake of consistency, the perturbation to the deterministic orbit must be the same order as noise in \eqref{orga4130d7}, that is \(\alpha(\epsilon) = \mathcal{O}(\beta(\epsilon))\) (and vice versa) or \(\lim_{\epsilon \to 0} \alpha(\epsilon) / \beta(\epsilon) = c\) where \(c\) is some real constant. Thus to leading order we have 
</p>

\begin{equation}
\label{org60ecbbc}
\mrm{d}y_t = \tilde{J}(t) y_t \mrm{d}t + 
c \tilde{b}(t)\mrm{d}{W_t}, 
\end{equation}

<p>
where \(\tilde{J}(t) = J(\bar{x}(t))\) and \(\tilde{b}(t) = b(\bar{x}(t))\) are, respectively, the Jacobian and noise amplitude in matrix form. 
</p>

<p>
This derivation corresponds having a perturbative solution to the SDE \eqref{orga4130d7} with the form
</p>

\begin{equation}
\label{org18376fe}
x_{t} = x^{(0)}_t + \alpha x^{{(1)}}_t + \alpha^2 x^{(2)}_t + \alpha^3 x^{(3)}_t + \cdots 
\end{equation}

<p>
where \(x^{(k)}_t \in \mathbb{R}^n\) and the index is used to indicate the order of perturbation and not the index of the vector component. Inserting the series \eqref{org18376fe} into \eqref{orga4130d7}, we obtain the set of SDEs
</p>

\begin{aligned}
\label{org1557f75}
\mrm{d} x^{(0)}_t &= a(x^{(0)}) \mrm{d}t, \quad x^{(0)}_0 = x_0 \\
\mrm{d} x^{(1)}_t &= x^{(1)}_t \partial_{x}a(x)_{x \to x^{(0)}_t} \mrm{d}t +  b(x^{(0)}_t) \mrm{d}W_t, \quad x^{(1)}_0 = 0 \\
\phantom{\mrm{d}x^{(1)}_t} & \vdots
\end{aligned}

<p>
which is equal to [BROKEN LINK: eq-sde-dev]-lead-o with \(y_t = x^{(1)}_t\) being the first-order (stochastic) correction to the deterministic solution. For the full derivation (and proof) look at Chapter 2 of [Freidlin-Wentzell](<a href="https://link.springer.com/book/10.1007/978-3-642-25847-3">https://link.springer.com/book/10.1007/978-3-642-25847-3</a>) specifically Theorems 2.1 and 2.2.
</p>

<p>
Notice thus far that we have not explicitly assumed any constraints on \(\tilde{J}(t)\), however, it must be negative semi-definite since it is evaluated on an orbit that exists on a stable invariant manifold. Further if we assume that the Jacobian to have at-least one eigenvalue with negative real parts with a corresponding stable eigenspace, then the fluctuations projected on to the stable eigenspace is an Ornstein-Uhlenbeck.
</p>

<p>
To see this, let the eigenvalues of the Jacobian be \(\{\lambda_1,\dots,\lambda_r,\dots,\lambda_n\}\) ordered such that for \(i = 1, \dots, r\) we have \(\Re(\lambda_i) < 0\) which corresponds to the stable subspace,and for \(i = r+1,\dots,n\) we have \(\Re(\lambda_i) \geq 0\) which corresponds centre and unstable subspace. Let
</p>
\begin{equation}
\label{org6b0c039}
\mmat{R}(t) = \begin{pmatrix} \mmat{P}_s(t) \\ \mmat{P}_{o}(t) \end{pmatrix}
\end{equation}
<p>
be a full rank unitary operator, where \(\mmat{P}_s\) is the projection operator onto the stable eigenspace \(E^s \subset \mathbb{R}^n\) spanned by the eigenvectors associated with \(\{\lambda_1,\dots,\lambda_r\}\). Let \(z_t = \mmat{R} y_t\) and using It\(\bar{\text{o}}\)'s lemma with \eqref{org60ecbbc} we obtain
</p>
\begin{equation}
\label{orge92b4f0}
\rmd z_t =  \mmat{R} \tilde{J} \mmat{R}^{-1} z_t + \mmat{R}\, \tilde{b}\, \rmd W_t.
\end{equation}
<p>
From \eqref{orge92b4f0}, we can obtain the evolution of the covariance, i.e. the Lyapunov equation 
</p>
\begin{equation}
\label{orgd0d372c}
\diffl{\mmat{\Sigma}}{t} = \mmat{A}(t) \mmat{\Sigma} +  \mmat{\Sigma} \mmat{A}^{\trans}(t)
+ \mmat{D}(t)
\end{equation}
<p>
where \(\mmat{A} = \mmat{R} \tilde{J} \mmat{R}^{-1}\) and \(\mmat{D} = \mmat{R}\, \tilde{b}\). If all the eigenvalues of the Jacobian have positive real part, then Equation \eqref{orge92b4f0} gives a time dependent Ornstein-Uhlenbeck. Notice that we have
</p>
\begin{equation}
\label{org9173c0a}
\mmat{\Sigma} = 
\begin{pmatrix}
\Sigma_{\mrm{ss}} & \Sigma_{\mrm{so}}\\
\Sigma_{\mrm{os}} &  \Sigma_{\mrm{oo}}
\end{pmatrix}
\end{equation}
</div>
<div id="outline-container-orgb9eb4ec" class="outline-3">
<h3 id="orgb9eb4ec"><span class="section-number-3">1.1.</span> Example</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Consider the following two dimensional system where
</p>
\begin{equation}
\label{org711f17f}
\begin{pmatrix}
\rmd y^{(1)}_t \\
\rmd y^{(2)}_t 
\end{pmatrix}
=
\begin{pmatrix}
-k & \epsilon \\
\epsilon & \delta
\end{pmatrix}
\begin{pmatrix}
y^{(1)}_t \\
y^{(2)}_t 
\end{pmatrix}
+
2
\begin{pmatrix}
\sigma_1 & 0 \\
0 & \sigma_2
\end{pmatrix}
\begin{pmatrix}
\rmd W^{(1)}_t \\
\rmd W^{(2)}_t
\end{pmatrix}
\end{equation}
<p>
\(k, \sigma_1, \sigma_2 \in \mathbb{R}^+\), while \(\epsilon, \delta \in \mathbb{R}\). If we consider the steady-state Lyapunov equation we have three simultaneous equations
</p>
\begin{equation}
\label{orgefc331a}
\begin{aligned}
-k\Sigma_{\mrm{ss}} + \epsilon\Sigma_{\mrm{so}} + \sigma_1 &= 0, \\
(\delta - k)\Sigma_{\mrm{so}} + \epsilon(\Sigma_{\mrm{oo}} +\Sigma_{\mrm{ss}}) &= 0, \\
 \epsilon \Sigma_{\mrm{so}} + \delta\Sigma_{\mrm{oo}} + \sigma_2 &= 0, \\
\end{aligned}
\end{equation}
<p>
which gives us (check!)
</p>
\begin{equation}
\label{org7ab4524}
\Sigma_{\mrm{ss}} = \frac{\epsilon^2(\sigma_2 - \sigma_2) - \sigma_1 \delta (\delta - k)}{\epsilon^2 \delta +  k \delta (\delta - k) + \epsilon^2 k}
\end{equation}



<hr />


<p>
Projecting \eqref{org60ecbbc} onto \(E^s\) gives
</p>

\begin{equation}
\label{orgd75530c}
\rmd z_t = 
\end{equation}


\begin{equation}
\label{org678c4d9}
\mathrm{d}z_t =  \mmat{P}_{s} \tilde{J}(t) \mmat{P}^{-1}_s \z_t \mrm{d}t
\tilde{J}^{\mrm{s}}(t) z_t \,\mathrm{d}t + c\,b^{\mrm{s}}(t) \,\mathrm{d}W_t
\end{equation}

<p>
where \(z_t = P_s y_t, J_s = P_s \tilde{J}(t) P_s\) is Hurwitz (all eigenvalues have strictly negative real part), and \(b_s(t) = P_s \tilde{b}(t)\).
</p>

<p>
If \(\tilde{J}(t)\) is constant in time (e.g., in the neighbourhood of a fixed point), the above SDE is exactly the multivariate Ornsteinâ€“Uhlenbeck process,
\(\mathrm{d}z_t = A z_t \,\mathrm{d}t + \Sigma \,\mathrm{d}W_t\),
with \(A = J_s\) and \(\Sigma = c\,b_s\), which admits a stationary Gaussian distribution with zero mean and covariance matrix \(C\) satisfying the Lyapunov equation \(A C + C A^\top + \Sigma \Sigma^\top = 0\).
</p>

<p>
This shows that in the stable directions the fluctuations remain bounded and Gaussian in the small-noise limit, while any neutral or unstable directions require higher-order analysis or additional constraints to control their growth.
</p>
</div>
</div>
</div>
<div id="outline-container-org10f6d60" class="outline-2">
<h2 id="org10f6d60"><span class="section-number-2">2.</span> Examples and code</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0031a9;">import</span> numpy <span style="color: #0031a9;">as</span> np
<span style="color: #0031a9;">import</span> matplotlib.pyplot <span style="color: #0031a9;">as</span> pp
<span style="color: #0031a9;">import</span> prusty.prusty <span style="color: #0031a9;">as</span> pr
<span style="color: #7f0000;"># </span><span style="color: #7f0000;">pp.style.use("~/.config/matplotlib/stylelib/paper.mplstyle")</span>
</pre>
</div>


<p>
## Piecewise-constant 
<img src="figures/constant-ps.svg" alt="constant-ps.svg" class="org-svg" />
</p>

\begin{equation}
\label{org54426a6}
\lc
\begin{aligned}
\mrm{d}x_t &=  u\mrm{d}t + \sqrt{\epsilon} u \mrm{d}^{i}W_t, \\
\mrm{d}y_t &=  -v \mrm{sign}(x_t) \mrm{d}t + \sqrt{\epsilon} b^{2}_{i}(x_t, y_t) \mrm{d}^{i}W_t, \\
\end{aligned}
\rd.
\end{equation}

<p>
where \(u\) and \(v\) are constants and \(\mrm{sign}\) is the signum function. Suppose we employ the regularisation
</p>

\begin{equation}
\label{org71617ca}
\mrm{sign}(x) \sim
\mrm{sign}^{\epsilon}(x) = 
\lc
\begin{array}{ll}
-1 & x < -\frac{\epsilon}{2} \\
\Lambda^{\epsilon}(x) & |x| \in [-\frac{\epsilon}{2}, \frac{\epsilon}{2}] \\
\phantom{1} 1 & x > -\frac{\epsilon}{2}
\end{array}
\rd
\end{equation}

<p>
where \(\Lambda^{\epsilon}(x)\)  are the family of bounded functions on the closed interval \([-\epsilon/2, \epsilon/ 2]\), i.e.
</p>

\begin{equation}
\label{org3923150}
\Lambda^{\epsilon}(x) \in  
\left\{ f \in C^1([-\epsilon/2, \epsilon/2]) \,\middle|\,
\begin{array}{l}
f(\epsilon/2) = 1,\quad f(-\epsilon/2) = -1, \\
\sup_{x \neq \epsilon/2} f(x) < 1, \\
\inf_{x \neq -\epsilon/2} f(x) > -1
\end{array}
\right\}.
\end{equation}

<p>
This family of functions in the limit \(\epsilon \to 0\) all yeilds the discontinuous sign function and is illustrated in <a href="#org1bfdd55">No description for this link</a>. Notice that the (fix b) noise amplitude  is \(\mathcal{O}(\sqrt{\epsilon})\). This is in preparation for later analysis as the Gaussian noise correction to the deterministic dynamics of a chemical reaction in the thermodynamic limit is inversely proportional to the square root of the volume: \(1/ \sqrt{V} = \sqrt{\epsilon}\).
</p>

<p>
The choice of \(\Lambda^{\epsilon}(x)\), while not affecting the macroscopic dynamics, will obiously lead to different stationary distributions inside the layer.
</p>

<p>
If we consider in phase space we obtain trajectories that lead from an arbitrary initially condition to the surface \(\mathcal{D}\), where one would expect sliding motion we instead obtain rapid crossing and recrossing of the surface. 
</p>

<p>
When simulating one must use $\mathrm{d}t &le; &epsilon; $
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #7f0000;">#</span><span style="color: #7f0000;">| label: fig-const-vec-disc-phase
</span><span style="color: #7f0000;">#</span><span style="color: #7f0000;">| fig-cap: "A phase portrait of a trajectory in a piecewise constant field dt=1"
</span>
<span style="color: #00603f;">init_cond</span> <span style="color: #000000;">=</span> np.array<span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #000000;">-</span>1.0, 10.0<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>
<span style="color: #00603f;">d_mult</span> <span style="color: #000000;">=</span> np.array<span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span>0.5, 1.0<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>
<span style="color: #00603f;">ep</span> <span style="color: #000000;">=</span> 0.05

<span style="color: #00603f;">sigma</span> <span style="color: #000000;">=</span> np.array<span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #008899;">[</span>1.0, 0.0<span style="color: #008899;">]</span>, <span style="color: #008899;">[</span>0.0, 1.0<span style="color: #008899;">]</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>  <span style="color: #000000;">*</span> ep
<span style="color: #00603f;">num_points</span> <span style="color: #000000;">=</span> 500
<span style="color: #00603f;">num_trials</span> <span style="color: #000000;">=</span> 20000
<span style="color: #00603f;">num_treads</span> <span style="color: #000000;">=</span> 6

<span style="color: #00603f;">t_min_max</span> <span style="color: #000000;">=</span> <span style="color: #000000;">(</span>0.0, 500.0<span style="color: #000000;">)</span>

<span style="color: #00603f;">dat_pt</span>, <span style="color: #00603f;">dat_px</span> <span style="color: #000000;">=</span> pr.sde.constant_opposing_linear_cont<span style="color: #000000;">(</span>init_cond, d_mult, sigma, ep, t_min_max, num_points, num_trials, num_threads<span style="color: #000000;">)</span>
<span style="color: #00603f;">xx</span>, <span style="color: #00603f;">yy</span> <span style="color: #000000;">=</span> np.meshgrid<span style="color: #000000;">(</span>np.linspace<span style="color: #dd22dd;">(</span>0, 500, 10<span style="color: #dd22dd;">)</span>, np.linspace<span style="color: #dd22dd;">(</span><span style="color: #000000;">-</span>10, 10, 10<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>
<span style="color: #00603f;">uu</span> <span style="color: #000000;">=</span> xx <span style="color: #000000;">*</span> 0 <span style="color: #000000;">+</span> d_mult<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span>
<span style="color: #00603f;">vv</span> <span style="color: #000000;">=</span> yy <span style="color: #000000;">*</span> 0;
<span style="color: #00603f;">vv</span><span style="color: #000000;">[</span>yy <span style="color: #000000;">&gt;</span> 0<span style="color: #000000;">]</span> <span style="color: #000000;">+=</span> <span style="color: #000000;">-</span>d_mult<span style="color: #000000;">[</span>1<span style="color: #000000;">]</span>
<span style="color: #00603f;">vv</span><span style="color: #000000;">[</span>yy <span style="color: #000000;">&lt;</span> 0<span style="color: #000000;">]</span> <span style="color: #000000;">+=</span>  d_mult<span style="color: #000000;">[</span>1<span style="color: #000000;">]</span>

<span style="color: #00603f;">fig_t</span>, <span style="color: #00603f;">ax_ts</span> <span style="color: #000000;">=</span> pp.subplots<span style="color: #000000;">(</span>ncols<span style="color: #000000;">=</span>2, sharey<span style="color: #000000;">=</span><span style="color: #531ab6;">True</span>, figsize<span style="color: #000000;">=</span><span style="color: #dd22dd;">[</span>8,3<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>
ax_ts<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span>.quiver<span style="color: #000000;">(</span>xx, yy, uu, vv<span style="color: #000000;">)</span>
ax_ts<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span>.plot<span style="color: #000000;">(</span>dat_px<span style="color: #dd22dd;">[</span>:, 0, 0<span style="color: #dd22dd;">]</span>, dat_px<span style="color: #dd22dd;">[</span>:, 1, 0<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>
ax_ts<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span>.set_xlabel<span style="color: #000000;">(</span><span style="color: #00598b;">"x"</span><span style="color: #000000;">)</span>
ax_ts<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span>.set_ylabel<span style="color: #000000;">(</span><span style="color: #00598b;">"y"</span><span style="color: #000000;">)</span>

ax_ts<span style="color: #000000;">[</span>1<span style="color: #000000;">]</span>.plot<span style="color: #000000;">(</span>dat_pt<span style="color: #dd22dd;">[</span>:, 0<span style="color: #dd22dd;">]</span>, dat_px<span style="color: #dd22dd;">[</span>:, 1, 0<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>
ax_ts<span style="color: #000000;">[</span>1<span style="color: #000000;">]</span>.set_xlabel<span style="color: #000000;">(</span><span style="color: #00598b;">"t"</span><span style="color: #000000;">)</span>
ax_ts<span style="color: #000000;">[</span>1<span style="color: #000000;">]</span>.set_ylabel<span style="color: #000000;">(</span><span style="color: #00598b;">"y"</span><span style="color: #000000;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #7f0000;">#</span><span style="color: #7f0000;">| label: fig-const-vec-disc-phase-small-dt
</span><span style="color: #7f0000;">#</span><span style="color: #7f0000;">| fig-cap: "A phase portrait of a trajectory in a piecewise constant field dt=0.05"
</span>
<span style="color: #00603f;">init_cond</span> <span style="color: #000000;">=</span> np.array<span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #000000;">-</span>1.0, 10.0<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>
<span style="color: #00603f;">d_mult</span> <span style="color: #000000;">=</span> np.array<span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span>0.5, 1.0<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>
<span style="color: #00603f;">ep</span> <span style="color: #000000;">=</span> 0.05

<span style="color: #00603f;">sigma</span> <span style="color: #000000;">=</span> np.array<span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #008899;">[</span>1.0, 0.0<span style="color: #008899;">]</span>, <span style="color: #008899;">[</span>0.0, 1.0<span style="color: #008899;">]</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>  <span style="color: #000000;">*</span> ep
<span style="color: #00603f;">num_points</span> <span style="color: #000000;">=</span> 10000
<span style="color: #00603f;">num_trials</span> <span style="color: #000000;">=</span> 20000
<span style="color: #00603f;">num_treads</span> <span style="color: #000000;">=</span> 6

<span style="color: #00603f;">t_min_max</span> <span style="color: #000000;">=</span> <span style="color: #000000;">(</span>0.0, 500.0<span style="color: #000000;">)</span>

<span style="color: #00603f;">dat_pt</span>, <span style="color: #00603f;">dat_px</span> <span style="color: #000000;">=</span> pr.sde.constant_opposing_linear_cont<span style="color: #000000;">(</span>init_cond, d_mult, sigma, ep, t_min_max, num_points, num_trials, num_threads<span style="color: #000000;">)</span>
<span style="color: #00603f;">xx</span>, <span style="color: #00603f;">yy</span> <span style="color: #000000;">=</span> np.meshgrid<span style="color: #000000;">(</span>np.linspace<span style="color: #dd22dd;">(</span>0, 500, 10<span style="color: #dd22dd;">)</span>, np.linspace<span style="color: #dd22dd;">(</span><span style="color: #000000;">-</span>10, 10, 10<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>
<span style="color: #00603f;">uu</span> <span style="color: #000000;">=</span> xx <span style="color: #000000;">*</span> 0 <span style="color: #000000;">+</span> d_mult<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span>
<span style="color: #00603f;">vv</span> <span style="color: #000000;">=</span> yy <span style="color: #000000;">*</span> 0;
<span style="color: #00603f;">vv</span><span style="color: #000000;">[</span>yy <span style="color: #000000;">&gt;</span> 0<span style="color: #000000;">]</span> <span style="color: #000000;">+=</span> <span style="color: #000000;">-</span>d_mult<span style="color: #000000;">[</span>1<span style="color: #000000;">]</span>
<span style="color: #00603f;">vv</span><span style="color: #000000;">[</span>yy <span style="color: #000000;">&lt;</span> 0<span style="color: #000000;">]</span> <span style="color: #000000;">+=</span>  d_mult<span style="color: #000000;">[</span>1<span style="color: #000000;">]</span>

<span style="color: #00603f;">fig_t</span>, <span style="color: #00603f;">ax_ts</span> <span style="color: #000000;">=</span> pp.subplots<span style="color: #000000;">(</span>ncols<span style="color: #000000;">=</span>2, sharey<span style="color: #000000;">=</span><span style="color: #531ab6;">True</span>, figsize<span style="color: #000000;">=</span><span style="color: #dd22dd;">[</span>8,3<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>
ax_ts<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span>.quiver<span style="color: #000000;">(</span>xx, yy, uu, vv<span style="color: #000000;">)</span>
ax_ts<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span>.plot<span style="color: #000000;">(</span>dat_px<span style="color: #dd22dd;">[</span>:, 0, 0<span style="color: #dd22dd;">]</span>, dat_px<span style="color: #dd22dd;">[</span>:, 1, 0<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>
ax_ts<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span>.set_xlabel<span style="color: #000000;">(</span><span style="color: #00598b;">"x"</span><span style="color: #000000;">)</span>
ax_ts<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span>.set_ylabel<span style="color: #000000;">(</span><span style="color: #00598b;">"y"</span><span style="color: #000000;">)</span>

ax_ts<span style="color: #000000;">[</span>1<span style="color: #000000;">]</span>.plot<span style="color: #000000;">(</span>dat_pt<span style="color: #dd22dd;">[</span>:, 0<span style="color: #dd22dd;">]</span>, dat_px<span style="color: #dd22dd;">[</span>:, 1, 0<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>
ax_ts<span style="color: #000000;">[</span>1<span style="color: #000000;">]</span>.set_xlabel<span style="color: #000000;">(</span><span style="color: #00598b;">"t"</span><span style="color: #000000;">)</span>
ax_ts<span style="color: #000000;">[</span>1<span style="color: #000000;">]</span>.set_ylabel<span style="color: #000000;">(</span><span style="color: #00598b;">"y"</span><span style="color: #000000;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #7f0000;">#</span><span style="color: #7f0000;">| label: fig-const-vec-ep-dist
</span><span style="color: #7f0000;">#</span><span style="color: #7f0000;">| fig-cap: "Probability distribution in the $\\epsilon$-layer of the discontinuty surface"
</span><span style="color: #00603f;">x_space</span> <span style="color: #000000;">=</span> np.linspace<span style="color: #000000;">(</span><span style="color: #000000;">-</span>10<span style="color: #000000;">*</span>ep, 10<span style="color: #000000;">*</span>ep, 100<span style="color: #000000;">)</span>
<span style="color: #00603f;">norm_pdf</span> <span style="color: #000000;">=</span> <span style="color: #0031a9;">lambda</span> x, mu, sig_s: np.exp<span style="color: #000000;">(</span><span style="color: #000000;">-</span>0.5<span style="color: #000000;">/</span>sig_s <span style="color: #000000;">*</span><span style="color: #dd22dd;">(</span>x<span style="color: #000000;">-</span>mu<span style="color: #dd22dd;">)</span><span style="color: #000000;">**</span>2<span style="color: #000000;">)</span><span style="color: #000000;">/</span>np.sqrt<span style="color: #000000;">(</span>2<span style="color: #000000;">*</span>np.pi<span style="color: #000000;">*</span>sig_s<span style="color: #000000;">)</span>
<span style="color: #00603f;">yy</span>, <span style="color: #00603f;">xx</span> <span style="color: #000000;">=</span> np.histogram<span style="color: #000000;">(</span>dat_px<span style="color: #dd22dd;">[</span><span style="color: #000000;">-</span>1, 1, :<span style="color: #dd22dd;">]</span>, bins<span style="color: #000000;">=</span>100, density<span style="color: #000000;">=</span><span style="color: #531ab6;">True</span><span style="color: #000000;">)</span>
<span style="color: #00603f;">fig_p</span>, <span style="color: #00603f;">ax_p</span> <span style="color: #000000;">=</span> pp.subplots<span style="color: #000000;">()</span>
ax_p.scatter<span style="color: #000000;">(</span>0.5 <span style="color: #000000;">*</span> <span style="color: #dd22dd;">(</span>xx<span style="color: #008899;">[</span>1:<span style="color: #008899;">]</span> <span style="color: #000000;">+</span> xx<span style="color: #008899;">[</span>:<span style="color: #000000;">-</span>1<span style="color: #008899;">]</span><span style="color: #dd22dd;">)</span>, yy<span style="color: #000000;">)</span>
ax_p.set_xlim<span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #000000;">-</span>10<span style="color: #000000;">*</span>ep, 10<span style="color: #000000;">*</span>ep<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>
ax_p.set_xlabel<span style="color: #000000;">(</span>r<span style="color: #00598b;">"$y$"</span><span style="color: #000000;">)</span>;
ax_p.set_ylabel<span style="color: #000000;">(</span>r<span style="color: #00598b;">"$P(y)$"</span><span style="color: #000000;">)</span>;
</pre>
</div>



<p>
## Piecewise cycle 
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #7f0000;">#</span><span style="color: #7f0000;">| eval: true
</span><span style="color: #7f0000;">#</span><span style="color: #7f0000;">| cache: true
</span>
<span style="color: #00603f;">v</span> <span style="color: #000000;">=</span> 1.0;
<span style="color: #00603f;">al</span> <span style="color: #000000;">=</span> 4;
<span style="color: #00603f;">al_mult</span> <span style="color: #000000;">=</span> 1.0;
<span style="color: #00603f;">v</span> <span style="color: #000000;">=</span> 2 <span style="color: #000000;">*</span> np.pi;
<span style="color: #00603f;">sig_mult</span> <span style="color: #000000;">=</span> 1.96 <span style="color: #000000;">*</span> 0;
<span style="color: #00603f;">noise_amp</span> <span style="color: #000000;">=</span> 1 <span style="color: #000000;">/</span> <span style="color: #000000;">(</span>2 <span style="color: #000000;">*</span> np.pi <span style="color: #000000;">*</span> al<span style="color: #000000;">)</span> <span style="color: #000000;">*</span> 5.0;
<span style="color: #00603f;">y_disc</span> <span style="color: #000000;">=</span> 3

<span style="color: #00603f;">init_cond</span> <span style="color: #000000;">=</span> np.array<span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #000000;">-</span>al, 1.9<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>
<span style="color: #00603f;">d_mult</span> <span style="color: #000000;">=</span> np.array<span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #000000;">-</span>1.0, 0.00, 1.0, 0.0<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>
<span style="color: #00603f;">sigma</span> <span style="color: #000000;">=</span> np.array<span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #008899;">[</span>1.0, 0.0<span style="color: #008899;">]</span>, <span style="color: #008899;">[</span>0.0, 1.0<span style="color: #008899;">]</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span> <span style="color: #000000;">*</span> noise_amp 
<span style="color: #00603f;">ep</span> <span style="color: #000000;">=</span> 0.001


<span style="color: #00603f;">drift_params</span> <span style="color: #000000;">=</span> np.array<span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span>al, al_mult, v, y_disc<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>



<span style="color: #00603f;">num_points</span> <span style="color: #000000;">=</span> 1000000
<span style="color: #00603f;">num_trials</span> <span style="color: #000000;">=</span> 1
<span style="color: #00603f;">num_threas</span> <span style="color: #000000;">=</span> 1
<span style="color: #00603f;">t_min_max</span> <span style="color: #000000;">=</span> <span style="color: #000000;">(</span>0.0, 1000.0<span style="color: #000000;">)</span>


<span style="color: #00603f;">s_bound</span> <span style="color: #000000;">=</span> 1.0<span style="color: #000000;">/</span><span style="color: #000000;">(</span>v<span style="color: #000000;">**</span>2 <span style="color: #000000;">-</span> y_disc<span style="color: #000000;">**</span>2<span style="color: #000000;">)</span><span style="color: #000000;">*</span><span style="color: #000000;">(</span><span style="color: #000000;">-</span>v<span style="color: #000000;">*</span>y_disc<span style="color: #000000;">*</span>al <span style="color: #000000;">+</span> np.sqrt<span style="color: #dd22dd;">(</span>y_disc<span style="color: #000000;">**</span>4<span style="color: #000000;">*</span><span style="color: #008899;">(</span>v<span style="color: #000000;">**</span>2 <span style="color: #000000;">-</span> y_disc<span style="color: #000000;">**</span>2 <span style="color: #000000;">+</span> al<span style="color: #000000;">**</span>2<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>

<span style="color: #00603f;">sim_dat</span> <span style="color: #000000;">=</span> pr.sde.stochastic_trajectory_on_ring_with_disc<span style="color: #000000;">(</span>np.array<span style="color: #dd22dd;">(</span><span style="color: #008899;">[</span>s_bound,  y_disc<span style="color: #008899;">]</span><span style="color: #dd22dd;">)</span>, drift_params, sigma, ep, t_min_max, num_points, num_trials, num_threas<span style="color: #000000;">)</span>
<span style="color: #00603f;">segment_dat</span> <span style="color: #000000;">=</span> pr.sde.stochastic_trajectory_on_ring_with_disc<span style="color: #000000;">(</span>np.array<span style="color: #dd22dd;">(</span><span style="color: #008899;">[</span>s_bound,  y_disc<span style="color: #008899;">]</span><span style="color: #dd22dd;">)</span>, np.array<span style="color: #dd22dd;">(</span><span style="color: #008899;">[</span>al, al_mult, v, y_disc<span style="color: #008899;">]</span><span style="color: #dd22dd;">)</span>, 0.0 <span style="color: #000000;">*</span> sigma, ep, <span style="color: #dd22dd;">(</span>0, 1<span style="color: #dd22dd;">)</span>, num_points, num_trials, num_threas<span style="color: #000000;">)</span>

<span style="color: #00603f;">th_space</span> <span style="color: #000000;">=</span> np.linspace<span style="color: #000000;">(</span>0, 2<span style="color: #000000;">*</span>np.pi, 100<span style="color: #000000;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #7f0000;">#</span><span style="color: #7f0000;">| eval: true
</span><span style="color: #7f0000;">#</span><span style="color: #7f0000;">| cache: true
</span>
<span style="color: #00603f;">fig</span>, <span style="color: #00603f;">ax</span> <span style="color: #000000;">=</span> pp.subplots<span style="color: #000000;">()</span>

ax.plot<span style="color: #000000;">(</span>al<span style="color: #000000;">*</span>np.cos<span style="color: #dd22dd;">(</span>th_space<span style="color: #dd22dd;">)</span>, al<span style="color: #000000;">*</span>np.sin<span style="color: #dd22dd;">(</span>th_space<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>
<span style="color: #7f0000;"># </span><span style="color: #7f0000;">ax.plot(np.linspace(-al, al, 100), y_disc * np.ones(100))
</span>ax.plot<span style="color: #000000;">(</span>sim_dat<span style="color: #dd22dd;">[</span>1<span style="color: #dd22dd;">][</span>:, 0, 0<span style="color: #dd22dd;">]</span>, sim_dat<span style="color: #dd22dd;">[</span>1<span style="color: #dd22dd;">][</span>:, 1, 0<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>
ax.plot<span style="color: #000000;">(</span>segment_dat<span style="color: #dd22dd;">[</span>1<span style="color: #dd22dd;">][</span>:, 0, 0<span style="color: #dd22dd;">]</span>, segment_dat<span style="color: #dd22dd;">[</span>1<span style="color: #dd22dd;">][</span>:, 1, 0<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>
ax.scatter<span style="color: #000000;">(</span><span style="color: #000000;">-</span>1.17041, y_disc<span style="color: #000000;">)</span>
ax.scatter<span style="color: #000000;">(</span><span style="color: #000000;">-</span>0.348558, y_disc<span style="color: #000000;">)</span>
ax.set_aspect<span style="color: #000000;">(</span><span style="color: #00598b;">'equal'</span><span style="color: #000000;">)</span>

</pre>
</div>

<p>
Taking the stochastic trajectories, and then paramerising the 
</p>

<p>
\(\Phi: \mathbb{R}^2 \to \mathbb{R}^2 \times [0, 2\pi)\)
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #7f0000;">#</span><span style="color: #7f0000;">| eval: true
</span><span style="color: #7f0000;">#</span><span style="color: #7f0000;">| cache: true
</span>
pp.style.use<span style="color: #000000;">(</span><span style="color: #00598b;">"~/.config/matplotlib/stylelib/paper.mplstyle"</span><span style="color: #000000;">)</span>


<span style="color: #00603f;">fig</span>, <span style="color: #00603f;">ax</span> <span style="color: #000000;">=</span> pp.subplots<span style="color: #000000;">()</span>
<span style="color: #00603f;">x_vals</span> <span style="color: #000000;">=</span> sim_dat<span style="color: #000000;">[</span>1<span style="color: #000000;">]</span>
<span style="color: #00603f;">num_trajs</span> <span style="color: #000000;">=</span> x_vals.shape<span style="color: #000000;">[</span><span style="color: #000000;">-</span>1<span style="color: #000000;">]</span>

<span style="color: #00603f;">mean_traj</span> <span style="color: #000000;">=</span> segment_dat<span style="color: #000000;">[</span>1<span style="color: #000000;">][</span>:, :, 0<span style="color: #000000;">]</span>

<span style="color: #0031a9;">for</span> ti <span style="color: #0031a9;">in</span> <span style="color: #721045;">range</span><span style="color: #000000;">(</span>num_trajs<span style="color: #000000;">)</span>:
    <span style="color: #00603f;">x_traj</span> <span style="color: #000000;">=</span> x_vals<span style="color: #000000;">[</span>:, 0, ti<span style="color: #000000;">]</span>
    <span style="color: #00603f;">y_traj</span> <span style="color: #000000;">=</span> x_vals<span style="color: #000000;">[</span>:, 1, ti<span style="color: #000000;">]</span>

    <span style="color: #7f0000;"># </span><span style="color: #7f0000;">Compute theta
</span>    <span style="color: #00603f;">thi</span> <span style="color: #000000;">=</span> np.arctan2<span style="color: #000000;">(</span>y_traj, x_traj<span style="color: #000000;">)</span>
    
    <span style="color: #7f0000;"># </span><span style="color: #7f0000;">Wrap negative angles to [0, 2&#960;]
</span>    <span style="color: #00603f;">thi</span><span style="color: #000000;">[</span>thi <span style="color: #000000;">&lt;</span> 0<span style="color: #000000;">]</span> <span style="color: #000000;">+=</span> 2 <span style="color: #000000;">*</span> np.pi
    
    <span style="color: #7f0000;"># </span><span style="color: #7f0000;">Normalise to [0, 1]
</span>    <span style="color: #00603f;">thi_mod</span> <span style="color: #000000;">=</span> <span style="color: #000000;">(</span>thi <span style="color: #000000;">/</span> <span style="color: #dd22dd;">(</span>2 <span style="color: #000000;">*</span> np.pi<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span> <span style="color: #000000;">%</span> 1

    <span style="color: #7f0000;"># </span><span style="color: #7f0000;">Scatter for x component
</span>    ax.scatter<span style="color: #000000;">(</span>thi_mod, x_traj, s<span style="color: #000000;">=</span>0.08, c<span style="color: #000000;">=</span><span style="color: #00598b;">'r'</span>, alpha<span style="color: #000000;">=</span>0.2, edgecolors<span style="color: #000000;">=</span><span style="color: #00598b;">'none'</span><span style="color: #000000;">)</span>

    <span style="color: #7f0000;"># </span><span style="color: #7f0000;">Scatter for y component
</span>    ax.scatter<span style="color: #000000;">(</span>thi_mod, y_traj, s<span style="color: #000000;">=</span>0.08, c<span style="color: #000000;">=</span><span style="color: #00598b;">'r'</span>, alpha<span style="color: #000000;">=</span>0.2, edgecolors<span style="color: #000000;">=</span><span style="color: #00598b;">'none'</span><span style="color: #000000;">)</span>



<span style="color: #00603f;">mean_thi</span> <span style="color: #000000;">=</span> np.arctan2<span style="color: #000000;">(</span>mean_traj<span style="color: #dd22dd;">[</span>:, 1<span style="color: #dd22dd;">]</span>, mean_traj<span style="color: #dd22dd;">[</span>:, 0<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>
<span style="color: #00603f;">mean_thi</span><span style="color: #000000;">[</span>mean_thi <span style="color: #000000;">&lt;=</span> 0<span style="color: #000000;">]</span> <span style="color: #000000;">+=</span> 2 <span style="color: #000000;">*</span> np.pi
<span style="color: #00603f;">mean_thi_mod</span> <span style="color: #000000;">=</span> <span style="color: #000000;">(</span>mean_thi <span style="color: #000000;">/</span> <span style="color: #dd22dd;">(</span>2 <span style="color: #000000;">*</span> np.pi<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span> <span style="color: #000000;">%</span> 1

ax.plot<span style="color: #000000;">(</span>mean_thi_mod, mean_traj<span style="color: #dd22dd;">[</span>:, 0<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>    
ax.plot<span style="color: #000000;">(</span>mean_thi_mod, mean_traj<span style="color: #dd22dd;">[</span>:, 1<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>    

ax.set_xlabel<span style="color: #000000;">(</span>r<span style="color: #00598b;">"$\bar{\theta}$"</span><span style="color: #000000;">)</span>
ax.set_ylabel<span style="color: #000000;">(</span>r<span style="color: #00598b;">"$x,y$"</span><span style="color: #000000;">)</span>
fig.tight_layout<span style="color: #000000;">()</span>

</pre>
</div>
</div>
</div>

      
    </article>
    <!-- notes-panel is created dynamically if missing -->
  </main>
  <footer class="noty-footer">
    <div class="noty-footer-inner">
  <p>Generated with <code>emacs-noty</code>.</p>
</div>

  </footer>
  <script src="/assets/js/theme.js"></script>
  <script src="/assets/js/site.js"></script>
  <script src="/assets/js/refs.js"></script>
  <script src="/assets/js/scroll-restore.js"></script>
  <script src="/assets/js/load-math-macros.js"></script>
  <script src="/assets/js/link-preview.js"></script>
  <script src="/assets/js/mathjax-config.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script"></script>

</body>
</html>
